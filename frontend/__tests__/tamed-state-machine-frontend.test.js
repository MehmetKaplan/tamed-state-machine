// RUN THIS TEST AFTER BACKEND TESTS, BECAUSE IT USES THE SAME TEST DATA FOR THE STATE MACHINE

const apiBackend = 'http://development.computatus.com:61982'; // modify this with your backend

const tickLog = require('tick-log');
const tamedStateMachineFrontendHandlers = require('../tamed-state-machine-frontend');

const testExternalName = 'Test External Name';
const testExternalId = 'Frontend-Test-';
const testStateMachineName = 'Test State Machine for Document Approval';
const testGeneratedBy = 'Test Generated By';

let commonId = 1;

const preSubmit = (props) => { return "preSubmit is called" }
const preApprove = (props) => { return "preApprove is called" }
const preReject = (props) => { return "preReject is called" }
const preModify = (props) => { return "preModify is called" }
const preClose = (props) => { return "preClose is called" }
const postSubmit = (props) => { return "postSubmit is called" }
const postApprove = (props) => { return "postApprove is called" }
const postReject = (props) => { return "postReject is called" }
const postModify = (props) => { return "postModify is called" }
const postClose = (props) => { return "postClose is called" }


beforeAll(async () => {
	tamedStateMachineFrontendHandlers.init({
		apiBackend: apiBackend,
		debugMode: false,
		preFunctions: {
			preSubmit,
			preApprove,
			preReject,
			preModify,
			preClose,
		},
		postFunctions: {
			postSubmit,
			postApprove,
			postReject,
			postModify,
			postClose,
		}
	});
	jest.setTimeout(10000);
});

// jest.setTimeout(20000)

test('testHandler', async () => {
	const fSuccess = (props, retval) => {
		tickLog.success(`testHandler test backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval).toBeTruthy();
	}
	const fFail = (props, e) => {
		tickLog.error(`testHandler test failed`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.testHandler('This is the TEST field', fSuccess, fFail);
});

test('initiateInstance', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess = (props, retval) => {
		tickLog.success(`initiateInstance test backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail = (props, e) => {
		tickLog.error(`initiateInstance test failed`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess, fFail);
});

test('transition test', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess1 = (props, retval) => {
		tickLog.success(`transition test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail1 = (props, e) => {
		tickLog.error(`transition test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess1, fFail1);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`transition test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(2);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`transition test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Submit', testGeneratedBy, 'Frontend - transition test', undefined, fSuccess2, fFail2);
});


test('transition pre and post action test', async () => {
	let possibleTransitions;

	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess1 = (props, retval) => {
		tickLog.success(`transition pre and post action test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
		possibleTransitions = retval.payload;
	}
	const fFail1 = (props, e) => {
		tickLog.error(`transition pre and post action test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess1, fFail1);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`transition pre and post action test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(2);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`transition pre and post action test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	let result = await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Submit', testGeneratedBy, 'Frontend - transition test', possibleTransitions, fSuccess2, fFail2);
	tickLog.info(`Frontend transitionInstance result (should include pre and post function call results): ${JSON.stringify(result, null, ' ')}`, true);
	expect(result.preFuncResult).toBe("preSubmit is called");
	expect(result.postFuncResult).toBe("postSubmit is called");
});

test('getInstance', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess = (props, retval) => {
		tickLog.success(`getInstance test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail = (props, e) => {
		tickLog.error(`getInstance test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess, fFail);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`getInstance test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload).toMatchObject(
			{
				"external_name": testExternalName,
				"external_id": externalID,
				"valid": "Y",
			}
		);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`getInstance test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.getInstance(testExternalName, externalID, testStateMachineName, fSuccess2, fFail2)
});

/*
	getInstance: getInstance,
	initiateInstance: initiateInstance,
	deleteInstance: deleteInstance,
	getPossibleTransitions: getPossibleTransitions,
	getInstanceHistory: getInstanceHistory,
	getAllPossibleTransitions: getAllPossibleTransitions,
*/