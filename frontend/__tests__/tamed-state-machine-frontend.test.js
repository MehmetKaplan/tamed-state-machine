// RUN THIS TEST AFTER BACKEND TESTS, BECAUSE IT USES THE SAME TEST DATA FOR THE STATE MACHINE

const apiBackend = 'http://development.computatus.com:61982'; // modify this with your backend

const tickLog = require('tick-log');
const tamedStateMachineFrontendHandlers = require('../tamed-state-machine-frontend');

const testExternalName = 'Test External Name';
const testExternalId = 'Frontend-Test-';
const testStateMachineName = 'Test State Machine for Document Approval';
const testGeneratedBy = 'Test Generated By';

// made global just in case can be reused in other tests
const testTransitionsControl = [
	{ "from_state": "Init", "transition_name": "Submit", "to_state": "Submitted", "pre_transition_task_name": "preSubmit", "post_transition_task_name": "postSubmit" },
	{ "from_state": "Submitted", "transition_name": "Approve", "to_state": "Approved", "pre_transition_task_name": "preApprove", "post_transition_task_name": "postApprove" },
	{ "from_state": "Submitted", "transition_name": "Reject", "to_state": "Rejected", "pre_transition_task_name": "preReject", "post_transition_task_name": "postReject" },
	{ "from_state": "Approved", "transition_name": "Modify", "to_state": "Submitted", "pre_transition_task_name": "preModify", "post_transition_task_name": "postModify" },
	{ "from_state": "Approved", "transition_name": "Close", "to_state": "Closed", "pre_transition_task_name": "preClose", "post_transition_task_name": "postClose" },
	{ "from_state": "Rejected", "transition_name": "Modify", "to_state": "Submitted", "pre_transition_task_name": "preModify", "post_transition_task_name": "postModify" },
	{ "from_state": "Rejected", "transition_name": "Close", "to_state": "Closed", "pre_transition_task_name": "preClose", "post_transition_task_name": "postClose" }
];

let commonId = 1;

const preSubmit = (props) => { return "preSubmit is called" }
const preApprove = (props) => { return "preApprove is called" }
const preReject = (props) => { return "preReject is called" }
const preModify = (props) => { return "preModify is called" }
const preClose = (props) => { return "preClose is called" }
const postSubmit = (props) => { return "postSubmit is called" }
const postApprove = (props) => { return "postApprove is called" }
const postReject = (props) => { return "postReject is called" }
const postModify = (props) => { return "postModify is called" }
const postClose = (props) => { return "postClose is called" }


beforeAll(async () => {
	tamedStateMachineFrontendHandlers.init({
		apiBackend: apiBackend,
		debugMode: false,
		preFunctions: {
			preSubmit,
			preApprove,
			preReject,
			preModify,
			preClose,
		},
		postFunctions: {
			postSubmit,
			postApprove,
			postReject,
			postModify,
			postClose,
		}
	});
	jest.setTimeout(10000);
});

// jest.setTimeout(20000)

test('testHandler', async () => {
	const fSuccess = (props, retval) => {
		tickLog.success(`testHandler test backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval).toBeTruthy();
	}
	const fFail = (props, e) => {
		tickLog.error(`testHandler test failed`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.testHandler('This is the TEST field', fSuccess, fFail);
});

test('initiateInstance', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess = (props, retval) => {
		tickLog.success(`initiateInstance test backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail = (props, e) => {
		tickLog.error(`initiateInstance test failed`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess, fFail);
});

test('transition test', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess1 = (props, retval) => {
		tickLog.success(`transition test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail1 = (props, e) => {
		tickLog.error(`transition test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess1, fFail1);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`transition test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(2);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`transition test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Submit', testGeneratedBy, 'Frontend - transition test', undefined, fSuccess2, fFail2);
});


test('transition pre and post action test', async () => {
	let possibleTransitions;

	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess1 = (props, retval) => {
		tickLog.success(`transition pre and post action test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
		possibleTransitions = retval.payload;
	}
	const fFail1 = (props, e) => {
		tickLog.error(`transition pre and post action test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess1, fFail1);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`transition pre and post action test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(2);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`transition pre and post action test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	let result = await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Submit', testGeneratedBy, 'Frontend - transition test', possibleTransitions, fSuccess2, fFail2);
	tickLog.info(`Frontend transitionInstance result (should include pre and post function call results): ${JSON.stringify(result, null, ' ')}`, true);
	expect(result.preFuncResult).toBe("preSubmit is called");
	expect(result.postFuncResult).toBe("postSubmit is called");
});

test('getInstance', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess = (props, retval) => {
		tickLog.success(`getInstance test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail = (props, e) => {
		tickLog.error(`getInstance test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess, fFail);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`getInstance test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload).toMatchObject(
			{
				"external_name": testExternalName,
				"external_id": externalID,
				"valid": "Y",
			}
		);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`getInstance test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.getInstance(testExternalName, externalID, testStateMachineName, fSuccess2, fFail2)
});

test('deleteInstance', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess = (props, retval) => {
		tickLog.success(`getInstance test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail = (props, e) => {
		tickLog.error(`getInstance test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess, fFail);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`deleteInstance test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
	}
	const fFail2 = (props, e) => {
		tickLog.error(`deleteInstance test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.deleteInstance(testExternalName, externalID, testStateMachineName, fSuccess2, fFail2)

	try {
		const fSuccess3 = (props, retval) => {
			tickLog.error(`Get instance succeeded where it should NOT.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
			expect(true).toBe(false); // Should not come here
		}
		const fFail3 = (props, e) => {
			// Will be called but nothing special to be done
			tickLog.success(`Get instance failed as expected.\nprops: ${JSON.stringify(props, null, '  ')}`, true);
		}
		tickLog.info("***********************************************", true)
		tickLog.info("IT IS NORMAL THE BACKEND CALL TO FAIL HERE", true)
		await tamedStateMachineFrontendHandlers.getInstance(testExternalName, externalID, testStateMachineName, fSuccess3, fFail3);
	} catch (e) {
		tickLog.success(`Expected Error: ${JSON.stringify(e, null, '  ')}`, true);
		tickLog.info("***********************************************", true)
		expect(e.error).toBe("No instance found.");
	}
});

test('getPossibleTransitions', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	const fSuccess = (props, retval) => {
		tickLog.success(`getPossibleTransitions test step 1 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
	}
	const fFail = (props, e) => {
		tickLog.error(`getPossibleTransitions test failed at step 1`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fSuccess, fFail);

	const fSuccess2 = (props, retval) => {
		tickLog.success(`getPossibleTransitions test step 2 backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(1);
		expect(retval.payload[0]).toMatchObject({
			"from_state": "Init",
			"transition_name": "Submit",
			"to_state": "Submitted",
			"pre_transition_task_name": "preSubmit",
			"post_transition_task_name": "postSubmit"
		});
	}
	const fFail2 = (props, e) => {
		tickLog.error(`getPossibleTransitions test failed at step 2`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.getPossibleTransitions(testExternalName, externalID, testStateMachineName, fSuccess2, fFail2);
});

test('getInstanceHistory test', async () => {
	let externalID = `FE-${new Date().getTime()}-${commonId++}`;
	let counter = 0;
	const fS = (props, retval) => {
		tickLog.success(`transition test step ${counter} backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
	}
	const fF = (props, e) => {
		tickLog.error(`transition test failed at step ${counter}`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	counter++; // Step 1
	await tamedStateMachineFrontendHandlers.initiateInstance(testExternalName, externalID, testStateMachineName, testGeneratedBy, fS, fF);
	counter++; // Step 2
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Submit', testGeneratedBy, 'Frontend - transition test', undefined, fS, fF);
	counter++; // Step 3
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Reject', testGeneratedBy, 'Frontend - transition test', undefined, fS, fF);
	counter++; // Step 4
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Modify', testGeneratedBy, 'Frontend - transition test', undefined, fS, fF);
	counter++; // Step 5
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Approve', testGeneratedBy, 'Frontend - transition test', undefined, fS, fF);
	counter++; // Step 6
	await tamedStateMachineFrontendHandlers.transitionInstance(testExternalName, externalID, testStateMachineName, 'Close', testGeneratedBy, 'Frontend - transition test', undefined, fS, fF);

	counter++; // Step 7
	const fSuccess = (props, retval) => {
		tickLog.success(`******transition test step ${counter} backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(6);
		expect(retval.payload[0]).toMatchObject({
			"sm_state": "Closed",
			"transition_name": "Close",
			"transition_made_by": "Test Generated By",
			"comment": "Frontend - transition test"
		});
		expect(retval.payload[3]).toMatchObject({
			"sm_state": "Rejected",
			"transition_name": "Reject",
			"transition_made_by": "Test Generated By",
			"comment": "Frontend - transition test"
		},);
		expect(retval.payload[5]).toMatchObject({
			"sm_state": "Init",
			"transition_name": "instance initiated",
			"transition_made_by": "Test Generated By",
			"comment": "instance initiated"
		});
	}
	const fFail = (props, e) => {
		tickLog.error(`transition test failed at step ${counter}`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	await tamedStateMachineFrontendHandlers.getInstanceHistory(testExternalName, externalID, testStateMachineName, fSuccess, fFail);
});

test('getAllPossibleTransitions', async () => {
	let counter = 0;
	const fS = (props, retval) => {
		tickLog.success(`transition test step ${counter} backend call succeeded.\nprops: ${JSON.stringify(props, null, '  ')}\nretval: ${JSON.stringify(retval, null, '  ')}`, true);
		expect(retval.payload.length).toBe(7);
		let controlObject = retval.payload.map(r => { delete r.id; delete r.sm_id; return r; });
		expect(JSON.stringify(controlObject[0])).toBe(JSON.stringify(testTransitionsControl[0]));
		expect(JSON.stringify(controlObject[1])).toBe(JSON.stringify(testTransitionsControl[1]));
		expect(JSON.stringify(controlObject[2])).toBe(JSON.stringify(testTransitionsControl[2]));
		expect(JSON.stringify(controlObject[3])).toBe(JSON.stringify(testTransitionsControl[3]));
		expect(JSON.stringify(controlObject[4])).toBe(JSON.stringify(testTransitionsControl[4]));
		expect(JSON.stringify(controlObject[5])).toBe(JSON.stringify(testTransitionsControl[5]));
		expect(JSON.stringify(controlObject[6])).toBe(JSON.stringify(testTransitionsControl[6]));
	}
	const fF = (props, e) => {
		tickLog.error(`transition test failed at step ${counter}`, true);
		tickLog.error(`Called props: ${JSON.stringify(props, null, '  ')}`, true);
		tickLog.error(`Received error: ${JSON.stringify(e, null, '  ')}`, true);
		expect(true).toBe(false);
	}
	counter++; // Step 6
	await tamedStateMachineFrontendHandlers.getAllPossibleTransitions(testStateMachineName, fS, fF);
});